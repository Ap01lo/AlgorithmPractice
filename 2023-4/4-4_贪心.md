# Day4-贪心

## 0x00 题目

### 0x01 6和9组成的最大数字

#### 题目描述

给你一个仅由数字 6 和 9 组成的正整数 `num`。

你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。

请返回你可以得到的最大数字。



#### 思路

1. 得到数字位数

2. 将数字拆分成数组

3. 从前向后找到第一个6换成9

4. 重新组合数字

#### 解法

```c
int maximum69Number (int num){
    int nums[5];
    int count = 0;
    while(num%10){
        nums[count] = num%10;
        num = num/10;
        count++;
    }
    for(int i = count-1;i>=0;i--){
        if(nums[i] == 6){
            nums[i] = 9;
            break;
        }
    }
    int ans = 0;
    for(int i = 0;i<count;i++){
        ans += nums[i]*(pow(10,i));
    }
    return ans;
}
```

### 0x02 两栋颜色不同且距离最远的房子

#### 题目描述

街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第  i 栋房子的颜色。

返回 两栋 颜色 不同 房子之间的 最大 距离。

第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。

#### 思路

1. 第一层循环从第一个元素开始

2. 第二层循环从最后一个元素判断是否距离最远且颜色不同

3. 若满足条件，更新最大值

#### 解法

```c
int maxDistance(int* colors, int colorsSize){
    int dis = 0;
    for(int i=0;i<colorsSize-1;i++){
        for(int j=colorsSize-1;j>i;j--){
            if(colors[i]!=colors[j] && j-i>dis){
                dis = j-i;
                break;
            }
        }
    }
    return dis;
}
```

### 0x03 字符串中最大的奇数

#### 题目描述

给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 "" 。

子字符串 是字符串中的一个连续的字符序列。

#### 思路

1. 从最后一个元素向前遍历

2. 找到最后一个奇数，这个数以及之前的字符就是所求答案

3. 将该数的后一位置为'\0'表示结束

#### 解法

```c
char * largestOddNumber(char * num){
    int l = strlen(num);
    for(int i=l-1;i>=0;i--){
        int tmp = (int)(num[i]-'0') % 2;
        if(tmp){
            num[i+1] = '\0';
            break;
        }
        if(i==0){
            num[0] = '\0';
        }
    }
    return num;
}
```

### 0x04 使用特殊打字机键入单词的最少时间

#### 题目描述

有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 'a' 到 'z'。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 'a' 。

每一秒钟，你可以执行以下操作之一：

将指针 顺时针 或者 逆时针 移动一个字符。
键入指针 当前 指向的字符。
给你一个字符串 word ，请你返回键入 word 所表示单词的 最少 秒数 。

#### 思路

1. 总时间=寻找时间+键入时间(字符长度)

2. 寻找时间只需要用模运算算出间隔最小距离

3. 键入时间等于字符长度

4. 每次将指针更新至刚访问的字符处

#### 解法

```c
int getTime(int a,int b){
    int l,r;
    l = (a-b+26)%26;
    r = (b-a+26)%26;
    if(l<r){
        return l;
    }
    else{
        return r;
    }
}

int minTimeToType(char * word){
    int l = strlen(word);
    int p = (int)('a'-'a');
    int ans = 0;
    for(int i=0;i<l;i++){
        ans += getTime(p,(int)(word[i]-'a'));
        p = (int)(word[i]-'a');
    }
    ans += l;
    return ans;
}
```

### 0x05 十-二进制的最小数目

#### 题目描述

如果一个十进制数字不含任何前导零，且每一位上的数字不是 0 就是 1 ，那么该数字就是一个 十-二进制数 。例如，101 和 1100 都是 十-二进制数，而 112 和 3001 不是。

给你一个表示十进制整数的字符串 n ，返回和为 n 的 十-二进制数 的最少数目。

#### 思路

1. 数目等于字符中的最大数字

#### 解法

```c
int minPartitions(char * n){
    int max = 0;
    for(int i=0;i<strlen(n);i++){
        if((int)(n[i]-'0')>max){
            max = (int)(n[i]-'0');
        }
        if(max == 9){
            return max;
        }
    }
    return max;
}
```

### 0x06 保持城市天际线

#### 题目描述

给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。

城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。

我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。

在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。

#### 思路

1. 找到每行每列的最大值

2. 将每个元素增加到行列最大值中的较小值，即可得到增量

#### 解法

```c
int getMin(int a,int b){
    if(a<b){
        return a;
    }
    else{
        return b;
    }
}

int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){
    int rowMax[50];
    int colMax[50];
    int max;
    // rowMax
    for(int i=0;i<gridSize;i++){
        max = 0;
        for(int j=0;j<gridColSize[i];j++){
            if(grid[i][j]>max){
                max = grid[i][j];
            }
        }
        rowMax[i] = max;
    }
    // colMax
    for(int i=0;i<gridSize;i++){
        max = 0;
        for(int j=0;j<gridColSize[i];j++){
            if(grid[j][i]>max){
                max = grid[j][i];
            }
        }
        colMax[i] = max;
    }
    int ans = 0;
    for(int i=0;i<gridSize;i++){
        for(int j = 0;j<gridSize;j++){
            ans += getMin(rowMax[i],colMax[j])-grid[i][j];
        }
    }
    return ans;
}
```


